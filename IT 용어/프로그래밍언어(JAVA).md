### 프로그래밍 언어(40문항)

- 처음에 10문제는 자바 기초 상식 30문제는 코딩 결과값 유추입니다.
- 자바의 기본 문법

- 플밍관련 문제에서 ++, -- 이런 연산 가지고 결과 뭐나오는지 쓰는 문제



- ###### Servlet

  - 웹프로그래밍에서 클라이언트의 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그래밍 기술

  - 자바를 사용하여 웹을 만들기 위해 필요한 기술

  - 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램

    - ex) 어떠한 사용자가 로그인을 하려고 할 때. 사용자는 아이디와 비밀번호를 입력하고, 로그인 버튼을 누름
    - 그때 서버는 클라이언트의 아이디와 비밀번호를 확인하고, 다음 페이지를 띄워주어야 하는데, 이러한 역할을 수행하는 것이 서블릿(Servlet)

  - 클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트

  - html을 사용하여 요청에 응답한다.

  - Java Thread를 이용하여 동작한다.

  - MVC 패턴에서 Controller로 이용된다.

  - HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다. UDP보다 속도가 느리다.

  - HTML 변경 시 Servlet을 재컴파일해야 하는 단점이 있다.

  - 자바로 구현 된 CGI(별도로 제작된 웹서버와 프로그램간의 교환방식.

    ​								  CGI방식은 어떠한 프로그래밍언어로도 구현이가능하며, 

    ​								 별도로 만들어 놓은 프로그램에 HTML의 Get or Post 방법

    ​								 클라이언트의 데이터를 환경변수로 전달하고,

    ​								 프로그램의 표준 출력 결과를 클라이언트에게 전송하는 것

    ​								 즉, 자바 어플리케이션 코딩을 하듯 웹 브라우저용 출력 화면을 만드는 방법)

- ###### Java 특징

  - 객체지향

    - 객체(Object) 단위로 구성, 객체들이 서로 관계성 가짐

    - 실 세계의 개체 (Entity)를 속성 (Attribute)과 메소드 (Method = Operation)가 결합된 형태의 **객체 (Object)**로 표현하는 개념

      ex. 회사원 (개체), 이름, 주민번호, 주소, 연락처 (속성), 영업업무, 회계업무 (메소드)

    - 재사용성 증가

    - **추상화(Abstraction)**

      - 현상에 존재하는 객체의 주요특징을 추출하는 과정

      - 어떤 실체로부터 공통적인 부분이나 관심 있는 특성들만 한곳에 모은것

      - ex) 지구를 본따 만든 지구본

        ​	지구본은 실제 지구로 부터 관심 있는 특성들(대륙의 위치, 위도,경도)만 뽑아서 만든것이다. 지구를 추상화해서 지구본을 만들었다.

      - 객체지향에서의 추상화는 어떤 하위클래스들에 존재하는 공통적인 메소드를 `인터페이스`로 정의하는것을 예로 들 수 있다.

      - 실체 클래스들의 공통되는 필드와 메소드를 정의한 클래스를 말합니다.

        추상 클래스는 실체 클래스의 부모 클래스 역할을 할 수 있습니다.

        추상 클래스는 단독으로 객체 생성을 할 수 없고, 부모 클래스로만 사용됩니다.

        실체들 간에 공통되는 특성을 추출한 것을 말합니다.

        예를 들어 새, 곤충, 물고기를 동물이라고 일컫는 것과 같이 공통되는 특성을 추출하여 의미론적으로 접근한 것입니다.

        `삼성, 현대, LG => 회사(추상)`

      - 실체 클래스가 가져야할 필드와 메소드를 추상 클래스에 미리 정의해 놓고 실체 클래스는 추상 클래스를 무조건 상속 받아 작성토록 합니다.

    - **캡슐화(Encapsulataion)**

      - 하나의 클래스 안에 데이터와 기능을 담아 정의하고, 중요한 데이터나 복잡한 기능 등은 숨기고 외부에서 사용에 필요한 기능만을 공개하는 것
      - 비슷한 역할을 하는 속성과 메소드들을 하나의 클래스로 모은것을 캡슐화 라고 한다. 캡슐화에 속한 개념으로 `정보 은닉(은닉성)`이라는것이 있는데, 캡슐 내부의 로직이나 변수들을 감추고 외부에는 기능(api)만을 제공하는 것
      - `접근 제한자`: 필드, 메소드, 생성자에서 사용 가능
        - `public`: 모든 접근 허용(클래스에서만 사용 가능)
        - `protected`: 상속관계가 없는 다른 패키지 클래스 차단
          - 클래스 앞에 사용 불가능
          - 다른 패키지에 있는 클래스가 protected가 있는 해당 클래스 자식이면 사용 가능
        - `default`: 다른 패키지 클래스 전부 차단
          - 다른 패키지와의 클래스 선언과 생성자/메소드/필드의 호출이 불가능
          - 동일 패키지 내에서만 사용이 가능
        - `private`: 모든 외부에 있는 클래스 접근 차단
          - 자기 클래스 내부에서만 사용 가능, 동앨 패키지 내 다른 클래스는 사용 불가능

    - **상속(Inheritance)**

      - 객체 정의 시 기존에 존재하는 객체의 속성과 기능을 상속받아 정의하는 것

      - 클래스를 재사용 하는 것

      - 상위 클래스를 하위 클래스에서 상속 받게 되면 상위 클래스의 멤버변수나 메소드를 그대로 물려 받을 수 있다

      - 상속이 있기 때문에 코드를 재활용할 수 있고 그렇기 때문에 생산성이 높고 유지보수 하기가 좋고, 객체의 다형성을 구현할 수 있다. 

      - 자식(하위,파생) 클래스가 부모(상위) 클래스의 멤버를 물려받는 것

        자식이 부모를 선택해서 물려 받는 것

        상속 대상 : 부모의 필드와 메소드

    - **다형성(Polymorphism)**

      - 같은 타입 또는 같은 기능의 호출로 실행 결과가 다양한 객체를 대입(이용)할 수 있는 성질
      - 같은 모양의 함수가 상황에 따라 다르게 동작 하는것
      - 객체를 부품화시킬 수 있음
      - **오버로딩**
        - 함수의 이름은 같으나 함수의 매개변수 숫자, 타입등을 달리해서 다르게 사용하는것
      - **오버라이딩**
        - 상위 클래스의 메소드를 하위 클래스에서 똑같은 이름으로 재정의 하는것
        - 이렇게 되면, c++의 경우에는 상위 클래스 타입 변수에 하위 클래스를 담은 상태에서 메소드를 호출하면 상위 클래스의 메소드가 호출되고, 하위 클래스 타입 변수에 하위 클래스를 담으면 하위 클래스의 메소드가 호출된다.
        - 즉, 메소드의 이름은 똑같은데, 상황(상위 클래스의 참조 변수냐 하위 클래스의 참조 변수냐)에 따라 호출 되는 메소드가 다른것이다.

  - 플랫폼 독립적

    - HW에 상관없이 JVM이 설치되면 Java로 작성된 응용프로그램 실행 가능

  - 간단

    - 쉽게 접근 가능

  - 분산 프로그래밍 지원

    - 네트워크 이용 프로그래밍 지원, 원격 접속 가능

  - 멀티 스레드

    - 운영체제에 종속적이지 않은 독립적인 설계

- ###### 가비지 컬렉터(Garbage Collector)

  - 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능

  - 더 이상 사용할 수 없게 된 영역이란, 어떤 변수도 가리키지 않게 된 영역

  - 가비지는 **'정리되지 않은 메모리'**, **'유효하지 않은 메모리 주소'**, **주소를 잃어버려서 사용할 수 없는 메모리**

  - 메모리가 부족할 때 **쓰레기(가비지)를 정리해주는 프로그램**

  - 되면 정리되지 않은 채로 남겨져있는 메모리들은 사용되지도 않으면서 자리를 차지하고 있는 유효하지 않은 메모리를 JVM의 가비지 컬렉터가 다른 용도로 사용할 수 있게 **'메모리 해제'**를 시키는 프로그램

  - JVM은 메모리를 부여받고 열심히 프로그램들을 실행하다가 메모리가 부족해지는 순간이 오면 OS에게 추가로 메모리를 더 요청하게 된다.

    바로 이 **메모리를 더 달라고 요청하는 때에 가비지 컬렉터(Garbage Collector)가 실행된다.**

    또, 서버 프로그램인 경우에는 24시간 내내 돌아가는데, 이 때에는 JVM이 한가할 때(idle time) 가비지 컬렉터가 실행된다.

    (JVM이 종료되면, 당연히 사용하던 모든 메모리는 OS에게 반납된다.)

- 생성자함수 부모랑 자식 생성자 관련되서도 중간 중간 출력문 넣어놓고 결과
- 예외처리 문법 부분이나 이 상황에서 맞지 않는 Exception 고르기
- object, string 같은 클래스 객체에 있는 메소드도 뭐 있는지 알아야 풀 수 있는 문제도 있었다.
- 인터페이스
- arraylist, hashmap 같은 자료구조 프레임워크 관련 문제도 몇 개 있었다.
- 오버로딩과 오버라이딩 차이점
- 기본 wrapper 클래스가 아닌것 int 형 -> Int 
- 데이터 타입 바이트 크기가 다른것 인트형인데 2바이트로 써져있음
- case: break 유무 확인하고 풀기 - 결과값 고르기
- char 와 int 형 비교시 객체가 가르키는 주소가 같은지 문자열이 같은지 고르는게 나옵니다

\- static 초기화후 객체생성을 했을때 출력 메세지가 몇번나오는가

\- 클래스상속에 관한 문제 클래스는 1개이상 상속가능하다 와같이 기본적인것들

\- 인터페이스 상속시 implements 고르는 문제

\- 해쉬 또는 리스트 넣고 빼고 그다음에 나오는 출력값

\- 오브젝트 하위 매소드가아닌것 equals toString ...

\- JVM은 운영체제에 종속적이다.

\- 객체 호출 순서 - 상속이 된 부모객체의 생성자 호출하기

\- 부모객체 = new 자식객체시 오버라이딩된 함수가 호출되는거 아냐

\- this.정보 =  정보; 두개의 정보는 다른걸 알아야함.

\- 참조변수(배열 열거 클래스 인터페이스)의 생성원리와 스트링클래스와 오브잭트 비교 방식에 대해 잘 이해해야한다고 생각합니다.

\- 출제 범위는 예외처리 및 해쉬맵등 자료구조 메소드 입력 제거 출력 까지 공부하면 될것같습니다.

\- 배열 할당 중 틀린 것

제네릭 기법

\- 프로그램 실행 결과

\- 오버라이딩/오버로딩/인터페이스 상속

\- 생성자

함수 호출 순서

예외처리(try/catch)
