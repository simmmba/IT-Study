### SW공학

- ###### 소프트웨어공학

  - 소프트웨어 위기를 극복. 개발 ,운용 ,유지보수, 폐기에 대한 쳬계적인 접근 방안 연구함으로써 생산성 과 품질 향상
  - 계획, 시행, 기록, 유지보수 용이, 재사용 가능, 비용과 자원의 효율적 사용 등

- ###### 폭포수 모델

  - 전체 개발 과정을 물 흐르듯이 한 단계씩 완성하고 다음 단계에서 피드백하고 다음단계로 나아가면서 차례대로 처리하는 과정

  - 전 단계가 수행되어 완료되기 전에는 다음 단계로 진행할 수 없도록 제한

  - *장점* : 복잡성이 낮고 진행과정이 세분화되어 관리와 이해가 용이함.

    ​		   다수의 소프트웨어 경험 보유.

  - *단점* : 거대한 소프트웨어나 구체적인 요구사항에 대한 처리가 어려움. 

    ​		   후반부 리스크가 전체 설계를 좌지우지할 수도 있음.

    ​		   시스템이 개발 완료되는 시점에야 완성이 가능해 피드백을 빨리 볼수가 없음.

- ###### 반복적 모델

  - 초기 반복주기에 리스크를 포함시켜 개발.
  - 사전에 설계를 많이 하지 않고, 주기마다 스파이크솔루션을 미리 만들어 부딪힐 수 있는 기술적인 문제에 대해 미리 테스트하고 결과에 따라 작은 범위의 설계를 반복
    - 장점 : 리스크가 초기에 발견 됨, 매번 바뀌는 유동적인 요구사항을 반영하는데 용이하다. 빠른 피드백
    - 단점 : 경험 부족으로 관리 어려움. 조직,계약, 규모 등에 제약이 생김.

- ###### 프로토타이핑 모형(원형 모델,Prototyping Model)

  - 폭포수 모델의 단점을 보완한 모델

  - 점진적으로 시스템을 개발해 나가는 방법.

  - 고객의 요구사항을 정확히 파악하기 어려울때 사용하는 방법

  - 샘플을 먼저 개발한 후 고객의 피드백을 받고 샘플(Prototype=원형)을 폐기하고 다시 개발.

  - *장점* :  원형을 바탕으로 빠른 개발과 고객의 피드백을 받을 수 있음.

  - *단점* : 대규모의 프로젝트에는 부적합

    ​			단기간 제조 시 비효율적인 알고리즘이나 언어로 인한 낮은 성능, 낮은 신뢰도, 기능 제한적

  - 견본품 만들어서 고객 피드백을 얻은 다음 세련화 또는 정제, 사용자 요구분석에 초점을 맞춤.

  - `계획 – 위험 분석 – 공학(개발 및 검증) – 사용자 평가 ` 반복

- ###### 나선형 모형(Spiral Model)

  - 폭포수 모델 + 프로토타입 모델(반복) + `위험분석`

  - 점층적 개발 모델

  - 중간중간 마다 위험분석을 하며 문제가 있을 경우 프로젝트를 중단하는 것이 목적 == 위험관리

  - 가장 현실적 소프트웨어공학 패러다임

  - 고 비용의 시스템 개발이나 많은 시간이 걸리는 큰 시스템 구축시(대규모 프로젝트) 선택되는 모델.

  - *단점* : 위험을 최소화/ 개발과 유지보수의 구분이 없음(유지보수없음)

      		 프로젝트 관리 복잡

    ​			많은 비용

- ###### V모델 (V Model)

  - 폭포수 모형에 `시스템 검증과 테스트, 작업`을 강조한 모델
  - 모듈의 상세설계를 단위테스트 과정에 검증하고 시스템 설계는 통합테스트 단계에 사용자의 요구는 시스템 테스트 과정에서 검증하는 방법
  - *장점* : 개발 후 발생하는 오류를 줄일 수 있음
  - *단점* : 반복이 없어 변경을 다루기가 쉽지 않음

- ###### 애자일 개발 프로세스(애자일 모델)

  - 폭포수 모델을 보완
  - 실질적인 코딩을 통한 방법론
  - 앞을 예측하며 개발을 하지 않고, 일정한 주기를 가지고 끊임없이 프로토 타입을 만들어내며 그때 그때 필요한 요구를 더하고 수정하여 하나의 커다란 소프트웨어를 개발해 나가는 adaptive style
  - 개발자와 고객 사이의 지속적 커뮤니케이션을 통하여 변화하는 요구사항을 수용한다.
  - 고객이 결정한 사항을 가장 우선으로 시행하고, 개발자 개인의 가치보다 팀의 목표를 우선으로한다.
  - 팀원들과 주기적인 미팅을 통해 프로젝트를 점검한다.
  - 주기적으로 제품 시현을 하고 고객으로 부터 피드백을 받는다.
  - 프로그램 품질 향상에 신경쓰며 간단한 내부 구조 형성을 통한 비용절감을 목표로한다. 
  - **스크럼(scrum) 개발 방법론**
    - https://zeddios.tistory.com/24 에 자세히 설명됨

  

- ###### 효과적 프로젝트 관리를 위한 3P 

  - 사람(People), 문제(Problem), 프로세스(Process) 

- ###### COCOMO모형 

  - 개발 복잡도에 따른 분류(Organic,Semidetached,Embedded)
  - 비용 추정 단계 및 적용변수 구체화 정도에 따른 분류(Basic,Intermediate,Detailed)

- ###### SCM(Software Configuration Management,소프트웨어 형상 관리)

  - 프로세스 모든 정보항목의 집합체. 소프트웨어 라이프 사이클 동안 발생되는 변경 관리 활동.

  - 형상 항목 : 시스템 명세서, 프로젝트 계획서, 설계 명세서, 원시 코드 목록, 사용자 매뉴얼, 변경 요청서 등

- ###### 소프트웨어 설계의 원리

  - 추상화, 캡슐화, 모듈화, 결합도(커플링), 응집도 
  - 결합도는 낮아야 좋고, 응집도는 높아야 좋다.

- ###### 흐름도(Flow Chart) 

  - 처리순서 그림 표시, 기호와 흐름선, 내용으로 구성
  - 내용 : 단자(개시,종료), 준비(초기값), 결정, 입출력, 처리

- ###### 구조적 프로그래밍

  - Dijkstra 제안, 가독서 향상과 수정 및 유지보수 용이를 위해 만듦
  - but 성능 저하와 과다한 모듈 호출 및 중복 발생 -> GOTO문의 부분적 허용

- ###### 검사 기법

  - **화이트박스 시험**

    - 논리적 구조, 복잡도 계산
    - 소스코드 형태로 추출 정보를 활용하여 논리적인 모든 경로를 테스트
    - 구조적 테스트
    - 설계에 초점을 둠
    - 구조, 논리흐름, 블랙 박스 테스트보다 비용이 적게듬
    - `기초경로검사, 구조검사, 루프검사, 데이터 흐름검사`

  - **블랙박스 시험**
    - 실행파일 형태(인터페이스)로 소프트웨어를 테스트
    - 제대로 동작하는가를 검증하는 방식
    - 자료구조, 외부 데이터 접근, 인터페이스, 성능에러 등에 관한 것들을 확인
    - 내부 구조가 어떻게 되어있는지 확인할 수 없다.
    - 결과물 상태를 보고 요구사항이 충족하는지 확인한다.
    - 어떠한 결과가 나올지 예측할 수 없기 때문에 test case를 많이 시도해보아야 하기 때문에 화이트박스 테스트보다 테스트 비용이 많이 든다. 
    - 내부에 어떤 보안기술들이 적용되어 있는지 알수 없음.
    - 결함 발견 목적
    - 입출력 위주, 데이터 위주시험 및 오류 예측
    - `동치분할검사, 경계값 분석, 원인-효과 그래프 검사, 비교검사, 오류예측검사`

  - **화이트박스, 블랙박스 차이점 & 예시**
    - 화이트박스는 `소스코드 ` 형태, 블랙박스 테스트는 `실행파일` 형태로 소프트웨어를 테스트
    - 게임 소프트웨어 내부의 프로그래밍 언어를 실행 단계에 맞게 추적하며 오류를 검사하는 것이 화이트박스 테스트
    - 게임을 직접 플레이하며 게임상으로 드러난 결과물을 검사하는 것이 블랙박스 테스트

- ###### 객체지향 소프트웨어공학(개발 방법론)

  - 추상화, 정보은닉, 캡슐화, 상속성, 다형성에 기초
  - 데이터에서 출발하여 데이터에 연관된 기능을 찾는 상향식 접근. (<-> 하향식접근)
  - `객체` : 데이터+연산(메소드) -> 캡슐화
  - `클래스` : 객체의 타입. 객체들이 갖는 속성과 적용연산을 정의하는 템플릿. 데이터 추상화.
  - `추상 클래스` : 서브 클래스들의 공통된 특성을 하나의 슈퍼클래스로 추출한 클래스. 객체를 생성할 목적을 가지고 있지 않으며 생성할 수도 없음. 점진적 개발에 용이
  - `메시지` : 한 객체가 다른 객체의 모듈을 부르는 과정. 함수 호출에 해당.메시지는 인터페이스를 통해 전달.

- ###### 캡슐화

  - 데이터와 함수를 하나로 묶는 것.
  - 세부적 구현사항이 외부로부터 분리되있어 변경 연산의 부작용 감소.

- ###### 정보 은닉

  - 자신의 정보를 숨기고 객체 자신의 연산을 통하여 정보 접근을 허용. 캡슐화로 구현된 개념

- ###### 추상화

  - 불필요한 부분 생략, 가장 중요한 것만 개략화

- ###### 상속성

  - 모든 것을 다 정의하지 않고 기존 클래스들의 속성을 상속받고 추가 구현만 하는 방법.
  - 재사용 증대

- ##### 다형성

  - 한 함수가 여러 클래스들에 정의되어 있는 현상. 
  - 같은 이름의 메소드를 다른 클래스에서 호출할 수 있음. 
  - 동적 바인딩에 의해 이루어짐.

- ###### 클라이언트/서버 시스템

  - 분산처리 시스템의 한 형태
  - `서버` : 클라이언트 시스템으로부터 받은 요구사항을 처리하여 결과를 클라이언트에게 돌려주는 시스템
  - `클라이언트` : 요구사항을 서버에게 지시하거나, 서버가 처리한 내용을 받는 시스템
  - `미들웨어` : 분산 환경에서 구성원들을 연결하고 구성원들 간의 차이를 극복하도록 범용으로 개발된 소프트웨어. 클라이언트와 서버 사이에 존재하는 소프트웨어.

- ###### 소프트웨어 3R

  - 완성된 소프트웨어 프로그램을 기반으로 역공학(Reverse-Engineering), 재공학(Re-Engineering), 재사용(Re-Use)를 통해 소프트웨어의 생산성을 극대화 하는 기법

  - **소프트웨어 3R의 필요성**

    - 소프트웨어 유지보수 효율성 향상 및 비용 절감
    - 소프트웨어 개발 생산성 향상
    - 소프트웨어 이해, 변경, 테스트 용이
    - 소프트웨어 변경 요구사항에 대한 신속한 대응
    - 소프트웨어 위기(소프트웨어 개발 대형화, 복잡화, Life-Cycle 감소) 극복

  - **소프트웨어 3R의 활성화 방안**

    - 재사용에 대한 비전 공유

    - - 경영자, 관리자, 개발자 간의 공통된 이해 필요
      - 재사용의 필요성 및 장점에 대한 비전 제시
      - 재사용 가능한 모듈을 회사의 자산으로 인식할 수 있도록 노력

    - 재사용 Infrastructure 구성

    - - 재사용을 위한 공동 Repository, Matrix 활용 시스템 구축
      - 재사용 프로세스의 구축 및 활용 관리
      - 체계적이고 지속적인 교육 실시 및 CBC, 객체지향방법론을 활용

  - **역공학(Reverse-Engineering)**

    - 기존 개발된 시스템을 CASE를 이용하여 사양서, 설계서 등의 문서로 추출하는 작업
    - 소스 코드 -> 문서화
    - 개발 단계를 역으로 올라가 기존 개발된 시스템의 코드나 데이터로부터 설계 명세서나 요구 분석서 등을 도출하는 작업

  - **재공학(Re-Engineering)**

    - 기조 시스템을 널리 사용되는 프로그래밍 표준에 맞추거나 고수준의 언어로 재구성하거나 타 하드웨어에서 사용할 수 있도록 변환하는 작업
    - 소프트웨어의 위기를 해결하기 위해 개발의 생산성이 아닌 유지 보수의 생산성으로 해결하려는 방법 == `예방 보수 , 유지 보수`

  - **재사용(Re-Use)**

    - 이미 개발되어 기능, 성능, 품질을 인정받았던 소프트웨어의 전체 또는 일부분을 다시 사용
    - 다른 시스템에 이용되고 있는 소프트웨어를 파악하고 재구성하여 새로운 시스템에 적용하기 위한 작업

- ###### 응집도(cohension, 높은게 좋음)

  - 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지를 나타내는 정도
  - 일반적으로 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 그것을 응집도가 높다고 표현
  - 집도가 높으면 프로그램을 쉽게 이해할 수 있으므로 유지보수성이 높아진다.
  - *응집도가 낮은 클래스의 문제점*
    - 이해하기 힘들고
    - 따로 재사용하기 힘들며
    - 유지보수하기 힘들고
    - 다른 클래스의 변화에 민감하다.

- ###### 결합도(coupling, 낮은게 좋음)

  - 소프트웨어 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지 나타내는 정도
  - 프로그램의 요소가 결합도가 낮다는 것은 그것이 다른 요소들과 관계를 그다지 맺지 않은 상태를 의미한다.
  - *결합도가 높은 클래스의 문제점*
    - 연관된 다른 클래스가 변경되면 더불어 변경해야 하고,
    - 수정하려는 클래스를 이해하기 위해 연관된 다른 클래스를 함께 이해해야 하고
    - 나중에 다른 프로그램에서 클래스를 재사용하기도 힘들다.