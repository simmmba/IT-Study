# 블록체인 구현 프로젝트

## 블록 체인

- 관리 대상 데이터를 '**블록**' 단위의 소규모 데이터가 P2P 방식을 기반으로 생성된 '**체인**' 형태의 연결고리 기반 '**분산**' 데이터 저장 환경에 저장해 누구도 임의로 수정할 수 없고, 변경 결과를 열람할 수 있는 분산 컴퓨티 기술 기반의 '**원장**' 관리 기술
- 분산 데이터 저장기술의 한 형태
- 지속적으로 변경되는 데이터를 모든 참여 노드에 기록한 변경 리스트
- 분산 노드의 운영자에 의한 임의 조작이 불가능
- 블록체인 기술은 비트코인을 비롯한 대부분의 암호화폐 거래에 사용
- 암호화폐의 거래과정은 탈중앙화된 전자장부에 쓰이기 때문에 블록체인 소프트웨어를 실행하는 많은 사용자들의각 컴퓨터에서 서버가 운영되어, 중앙에 존재하는 은행 없이 개인 간의 자유로운 거래 가능
- 구조체(객체) 값에 LinkedList로 엮은 모습과 유사
  - 포인터 참조가 아닌 **해시값** 참조로 연결

<br />

##### 블록

- 관리 대상 데이터

##### 체인

- 연결고리

<br />



### 블록 해시(Block Hash)

- 블록을 대표하는 해시값
- 다른 블록과 체인처럼 연결해줌

<br />

#### 생성 조건

- 블록 난이도에 따라 자동으로 설정된 '목표값'보다 더 작은 블록해시값을 찾아야 함
- 해시는 랜덤하게 생성되기 때문에, 수없이 많은 연산을 반복해서 미리 정해진 목표값 이하의 해시값이 나오도록 해야함
- 이 때, 랜덤한 해시값을 생성할 수 있도록 매번 임시값을 사용해야 하는데, 그 임시값이 바로 논스(**<u>nonce</u>**)

<br />

#### 해시(Hash) == 해시함수(Hash Function)

- 어떤 데이터 입력값(임의의 길이)을 넣어도 **고정 길이** 데이터(결과값)로 리턴(매핑)하는 기능(함수)
- <u>예시</u>: **나머지(modulas)**
  - n 값의 나머지 m 을 구하면 0 ~ m-1 범위의 값이 구해짐
  - n 을 1 로 줘도 되지만 엄청 큰 수를 준다고 해도 결과값은 0 ~ m-1 범위의 값
  - m 값만으로는 n 값을 정확히 되돌리지는 못함
- <u>특성</u>
  1. 어떤 값을 넣어도 비슷한 길이의 알 수 없는 난수가 결과로 출력
  2. 글자가 한글자만 바뀌어도 완전히 다른 결과가 출력
  3. 출력값으로 입력값을 예측할 수 없음
  4. 같은 내용을 입력값으로 주면 결과값은 항상 같음
- 블록에는 어떠한 데이터가 담겨 있고, 이것을 해시하면 고정된 길이의 해시값이 리턴됨

<br />



### 블록 구현

- 블록 : 구조체로 표현
- 구조체 내용
  - 이전 블록의 해시값을 기억할 변수
  - 현재 블록에서 간식해야 할 데이터

<br />



### 블록체인 구현

- 블록을 생성하면 직전에 만든 블록과 관계를 맺어줘야 함
- 그 관계는 해시값을 통해서 가질 수 있음
- 이전의 블록 해시값을 현재의 블록이 기억
- 생성된 블록의 해시값은 또 다음 블록이 기억
- 블록생성 마다 이런 과정을 반복하며 블록간의 관계가 맺어지게 되고 이를 블록체인이라고 함
- <u>예외적인 경우</u> : **블럭을 처음 만들 때**
  - 이전의 블록이 없기에 해시값도 없음
  - 이런 경우, empty 값(null 과는 다른) 혹은 random 값을 넣어줌
  - 앞으로의 반복되어질 블록체인의 과정 속에 던져질 최초 씨앗이 되는 블록이기에 이 블록의 직전 블록이란 것은 의미가 없음
  - 최초로 만든 블록 == **Genesis 블록**

<br /><br />



## 작업 증명(Proof Of Work)

### 블록을 수정한다면?

- 최초의 블록해시 값은 2번째 블록에서 기억
- 최초의 블록값이 1byte 라도 달라진다면 해시값은 완전히 달라짐
- 2번째 블록에서 이 변경된 해시값을 previous 해시값으로 변경 한다면 3번째 블록도 해시값이 달라짐
- 블록간에는 해시로 연결되어 있어서 이전의 블록을 변경한다는 것은 이후의 블록 모두가 변경되어야 한다는 것을 의미
- 이후의 블록 개수가 많으면 많아질수록 부담이 됨
- 현대 컴퓨터는 무척 빠르기 때문에 이 정도는 크게 부담스러운 일이 아니고, 블록을 만들 때 컴퓨터라도 빨리 만들지 못하게 만들어야 함
  - 블록 생성 속도가 지나치게 빠르게 되면 데이터 검색이 어려워 지고 저장 공간이 부담됨
  - 난이도를 통해 블록 생성 속도를 어느정도 일정하게 조정, 데이터에 대한 관리 측면
  - 일종의 숙제(work)를 줘서 빠른 시간내로 만들지 못하게 함

<br />

### Nonce

- 예시
  - SHA-256(암호화가 적용된 해시함수) 같은 해시함수를 사용해 첫번째 블록 해시값 "26409a99ee7..."을  구할 수 있음
  - 2번째 블록에서는 이 값을 보관한 상태로 해시값을 구함
    - "bba5583034..."값이 구해짐
  - 하지만 이제부터 해시값은 **"0"으로 시작하는 해시값만 사용**하려고함
    - "07cb7d1168..." 이런 0 으로 시작하는 해시값을 구하려함
    - 해시값을 변경하려면 구조체 값이 달라져야 변경이 가능(해시의 특성 참조)
    - 기존의 구조체 변수들(previous 해시, data) 을 변경하면 안됨, 이 값들은 반드시 보관할 값
    - **다른 변수(<u>nonce</u>)를 추가** -> 전체적인 구조체 인스턴스 값도 달라짐
    - 해시값이 바로 ‘0’으로 시작하지는 않음
    - 값을 조금씩 변경하면서 ‘0’으로 시작할 때까지 계속해서 변경을 가해보기
    - 좀더 구체적으로는 정수형(integer) 변수를 추가해 0 부터 값을 줌
    - 그런 후, 해시값을 구해보고 조건이 맞지 않으면 1 씩 증가시킴
    - 계속 변수값을 변경해서 해시를 구하다 보면 언젠가는 "0"으로 시작하는 해시가 나옴
    - 이런 목적으로 추가하는 변수 == **<u>nonce</u>**

<br />

### 작업증명(Proof of Work(Pow))
- nonce 를 올려가며 해시를 만들다 보면 언젠가는 "0"으로 시작하는 해시값이 나옴
- 만약 "0"이 한개가 아니라 "00" 처럼 2 개로 시작하는 해시를 구하라고 한다면 최종 해시값을 구하는 시간이 더 걸림
- 이렇게 난이도를 올려가며 해시를 구하는 시간을 조절할 수 있음
- 이렇게 숙제(work)를 열심히 하여 과제물(nonce)을제출하면, 구해진 nonce 값으로 해시값을 구해보고 일치하면 nonce와 해시값이 옳다고 판단
- 이렇게 nonce 를 변경해가며 최종 해시를 구하는 것 == **작업증명**
- 비트코인, 이더리움(변경 예정)에서 사용중인 방식

<br />

- 블록을 하나 수정하면 이후의 블록은 해시를 다시 구해야 하며 nonce 를 다시 풀어야함
- 시간 필요 == 블록생성에 비용 발생
- 만약 블록체인이 실행되고 있다, 중간의 블록을 악의적인 목적으로 수정을 하면 이후의 모든 블록을 변경해야하고, 매번 숙제를 다시 풀면서 구해야함

<br />

### 정리
- 작업증명을 통하여 최종 블록을 생성하는 것 == **블록 마이닝(채굴)**
- 보상, 트랜잭션, 분산 등 블록체인에서 다루지 않은 개념들이 많이 있지만 지금부터의 내용을 토대로 하나씩 범위를 넓히며 파악하면 블록체인이 어떻게 구현되어 있는지 이해하는데 도움이 됨